import os
import re
import io
import json
import tempfile
import subprocess
import logging
import time
from typing import Dict, List, Optional
from urllib.parse import urlparse

from flask import Flask, request, jsonify
from flask_cors import CORS

# OpenAI (transcri√ß√£o real)
from openai import OpenAI

# ffmpeg port√°til (sem apt-get)
import imageio_ffmpeg

# ======================================================
# Configura√ß√£o inicial
# ======================================================
app = Flask(__name__)
CORS(app)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s"
)

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()
OPENAI_MODEL = os.getenv("OPENAI_STT_MODEL", "gpt-4o-mini-transcribe").strip()
DOWNLOAD_TIMEOUT = int(os.getenv("DOWNLOAD_TIMEOUT", "120"))

# Cliente OpenAI (se houver chave)
client = OpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY else None

# Armaz√©m simples de cookies em mem√≥ria (por dom√≠nio/plataforma)
# Ex.: {"instagram.com": [{"name":"sessionid","value":"...","domain":".instagram.com",...}], ...}
COOKIE_STORE: Dict[str, List[Dict]] = {}

# ======================================================
# Utilidades
# ======================================================
def detectar_plataforma(url: str) -> str:
    try:
        host = (urlparse(url).hostname or "").lower()
    except Exception:
        return "desconhecida"
    if "tiktok.com" in host:
        return "tiktok"
    if "instagram.com" in host:
        return "instagram"
    if "youtube.com" in host or "youtu.be" in host:
        return "youtube"
    if "facebook.com" in host:
        return "facebook"
    return "desconhecida"


def _cookies_para_arquivo_netscape(cookies: List[Dict]) -> str:
    """
    Converte lista de cookies (estilo Chrome) para um arquivo Netscape cookies.txt,
    que o yt-dlp aceita. Retorna o caminho do arquivo tempor√°rio criado.
    """
    header = "# Netscape HTTP Cookie File\n" \
             "# This file was generated by Scriptfy server.\n"
    lines = [header]

    for c in cookies or []:
        name = (c or {}).get("name")
        value = (c or {}).get("value")
        domain = (c or {}).get("domain") or ""
        path = (c or {}).get("path") or "/"
        secure = "TRUE" if (c or {}).get("secure") else "FALSE"
        # expires: inteiro epoch ou 0
        expires = (c or {}).get("expires")
        if isinstance(expires, str):
            # tenta converter string pra int; se falhar, usa 0
            try:
                expires = int(expires)
            except Exception:
                expires = 0
        if expires is None:
            expires = 0

        if not name or value is None:
            continue

        # flag de dom√≠nio inicial com ponto?
        initial_dot = "TRUE" if domain.startswith(".") else "FALSE"
        line = f"{domain}\t{initial_dot}\t{path}\t{secure}\t{expires}\t{name}\t{value}\n"
        lines.append(line)

    content = "".join(lines)
    tmpf = tempfile.NamedTemporaryFile(delete=False, suffix=".cookies.txt", mode="w", encoding="utf-8")
    tmpf.write(content)
    tmpf.close()
    return tmpf.name


def _cookies_para_url(url: str) -> Optional[List[Dict]]:
    """
    Retorna cookies da COOKIE_STORE que combinem com o dom√≠nio do URL.
    Procura por chaves exatas e por sufixos (ex.: ".instagram.com").
    """
    try:
        host = (urlparse(url).hostname or "").lower()
    except Exception:
        return None
    if not host:
        return None

    # busca por chaves que sejam sufixo do host
    for key, items in COOKIE_STORE.items():
        key_norm = key.lower()
        if host == key_norm or host.endswith(key_norm):
            return items
    return None


def _ffmpeg_dir() -> str:
    ffmpeg_bin = imageio_ffmpeg.get_ffmpeg_exe()
    return os.path.dirname(ffmpeg_bin)


def baixar_audio(url: str) -> str:
    """
    Baixa/extrai √°udio do v√≠deo com yt-dlp + ffmpeg port√°til.
    Retorna o caminho de um arquivo .mp3 tempor√°rio.
    Lan√ßa RuntimeError("download_failed") em caso de falha.
    """
    saida_tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".mp3")
    saida_tmp.close()

    cmd = [
        "yt-dlp",
        "-x",
        "--extract-audio",
        "--audio-format", "mp3",
        "--audio-quality", "0",             # melhor qualidade poss√≠vel
        "--prefer-ffmpeg",
        "--ffmpeg-location", _ffmpeg_dir(),
        "--no-progress",
        "--no-warnings",
        "--quiet",
        "--geo-bypass",
        "--force-ipv4",
        "--retries", "3",
        "--fragment-retries", "3",
        "--add-header", "User-Agent: Mozilla/5.0",
        "-f", "bestaudio/best",
        "-o", saida_tmp.name,
        url,
    ]

    # Se houver cookies para este URL, injeta
    cookie_file = None
    try:
        cookies = _cookies_para_url(url)
        if cookies:
            cookie_file = _cookies_para_arquivo_netscape(cookies)
            cmd.extend(["--cookies", cookie_file])
    except Exception as e:
        logging.warning("N√£o foi poss√≠vel preparar cookies para yt-dlp: %s", e)

    logging.info("Executando yt-dlp (timeout %ss)...", DOWNLOAD_TIMEOUT)
    try:
        subprocess.run(cmd, check=True, timeout=DOWNLOAD_TIMEOUT)
        logging.info("‚úÖ √Åudio baixado: %s", saida_tmp.name)
        return saida_tmp.name
    except subprocess.TimeoutExpired:
        logging.error("‚è±Ô∏è yt-dlp excedeu timeout de %ss", DOWNLOAD_TIMEOUT)
        raise RuntimeError("download_failed")
    except subprocess.CalledProcessError as e:
        logging.error("‚ùå Falha ao baixar √°udio com yt-dlp: %s", e)
        raise RuntimeError("download_failed")
    finally:
        if cookie_file:
            try:
                os.remove(cookie_file)
            except Exception:
                pass


def transcrever_audio(path: str) -> str:
    """
    Transcreve o √°udio com OpenAI. Se n√£o houver chave, dispara erro
    para cair no stub (comportamento controlado).
    """
    if not client:
        raise RuntimeError("missing_openai_key")

    try:
        with open(path, "rb") as f:
            res = client.audio.transcriptions.create(
                model=OPENAI_MODEL,  # "gpt-4o-mini-transcribe" por padr√£o
                file=f,
            )
        texto = (getattr(res, "text", None) or "").strip()
        return texto
    except Exception as e:
        logging.error("‚ùå Erro na transcri√ß√£o: %s", e)
        raise RuntimeError("transcribe_failed")


# ======================================================
# Middlewares e Rotas
# ======================================================
@app.after_request
def add_cors_headers(resp):
    resp.headers["Access-Control-Allow-Origin"] = "*"
    resp.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
    resp.headers["Access-Control-Allow-Headers"] = "Content-Type, Authorization"
    return resp


@app.route("/health", methods=["GET"])
def health():
    return jsonify(status="ok", ffmpeg=_ffmpeg_dir(), has_openai=bool(OPENAI_API_KEY)), 200


@app.route("/ingest-cookies", methods=["POST", "OPTIONS"])
def ingest_cookies():
    """
    Recebe cookies do browser/extension e guarda em mem√≥ria por dom√≠nio.
    Payload esperado:
    {
      "domain": "instagram.com",
      "cookies": [
        {"name":"sessionid","value":"...","domain":".instagram.com","path":"/","secure":true,"expires": 0},
        ...
      ]
    }
    """
    if request.method == "OPTIONS":
        return ("", 204)

    data = request.get_json(silent=True) or {}
    domain = (data.get("domain") or "").strip().lower()
    cookies = data.get("cookies")

    if not domain or not isinstance(cookies, list):
        return jsonify(ok=False, error="missing_fields",
                       detail="domain (str) e cookies (list) s√£o obrigat√≥rios"), 400

    # saneia rapidamente
    valids: List[Dict] = []
    for c in cookies:
        if not isinstance(c, dict):
            continue
        name = c.get("name")
        value = c.get("value")
        if not name or value is None:
            continue
        valids.append({
            "name": name,
            "value": value,
            "domain": c.get("domain") or f".{domain}",
            "path": c.get("path") or "/",
            "secure": bool(c.get("secure", False)),
            "expires": c.get("expires", 0)
        })

    if not valids:
        return jsonify(ok=False, error="no_valid_cookies"), 400

    COOKIE_STORE[domain] = valids
    logging.info("üç™ Cookies armazenados para %s: %s", domain, [c["name"] for c in valids])
    return jsonify(ok=True, stored=len(valids)), 200


@app.route("/transcribe", methods=["POST", "OPTIONS"])
def transcribe():
    if request.method == "OPTIONS":
        return ("", 204)

    data = request.get_json(silent=True) or {}
    url = (data.get("url") or "").strip()

    if not url or not re.match(r"^https?://", url, re.I):
        return jsonify(ok=False, error="invalid_url", detail="Envie um 'url' com http(s)://"), 400

    plataforma = detectar_plataforma(url)
    logging.info("üîç Recebido link: %s (%s)", url, plataforma)

    audio_path = None
    try:
        # 1) download do √°udio
        audio_path = baixar_audio(url)

        # 2) transcrever
        texto = transcrever_audio(audio_path)

        # 3) retorno
        return jsonify(
            ok=True,
            plataforma=plataforma,
            title="Roteiro gerado com sucesso",
            transcript=texto or "(sem conte√∫do detectado)"
        ), 200

    except Exception as e:
        motivo = str(e)
        logging.warning("‚ö†Ô∏è Falha real, retornando stub. Motivo: %s", motivo)
        return jsonify(
            ok=True,
            plataforma=plataforma,
            title="Roteiro gerado (stub)",
            transcript=(
                "‚ö†Ô∏è N√£o foi poss√≠vel extrair/transcrever o √°udio real agora.\n\n"
                f"URL: {url}\nPlataforma detectada: {plataforma}\n\n"
                "Quando o motor real estiver ativo, o roteiro do v√≠deo aparecer√° aqui."
            )
        ), 200
    finally:
        if audio_path:
            try:
                os.remove(audio_path)
            except Exception:
                pass


# ======================================================
# Inicializa√ß√£o local
# ======================================================
if __name__ == "__main__":
    # Em dev local:  python app.py
    # No Render:     gunicorn app:app --timeout 600
    app.run(host="0.0.0.0", port=10000, debug=False)
    
